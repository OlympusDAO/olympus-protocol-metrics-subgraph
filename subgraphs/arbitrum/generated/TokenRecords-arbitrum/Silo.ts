// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  Address,
  BigInt,
  Bytes,
  Entity,
  ethereum,
  JSONValue,
  TypedMap} from "@graphprotocol/graph-ts";

export class AssetStatusUpdate extends ethereum.Event {
  get params(): AssetStatusUpdate__Params {
    return new AssetStatusUpdate__Params(this);
  }
}

export class AssetStatusUpdate__Params {
  _event: AssetStatusUpdate;

  constructor(event: AssetStatusUpdate) {
    this._event = event;
  }

  get asset(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get status(): i32 {
    return this._event.parameters[1].value.toI32();
  }
}

export class Borrow extends ethereum.Event {
  get params(): Borrow__Params {
    return new Borrow__Params(this);
  }
}

export class Borrow__Params {
  _event: Borrow;

  constructor(event: Borrow) {
    this._event = event;
  }

  get asset(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get user(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Deposit extends ethereum.Event {
  get params(): Deposit__Params {
    return new Deposit__Params(this);
  }
}

export class Deposit__Params {
  _event: Deposit;

  constructor(event: Deposit) {
    this._event = event;
  }

  get asset(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get depositor(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get collateralOnly(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }
}

export class Liquidate extends ethereum.Event {
  get params(): Liquidate__Params {
    return new Liquidate__Params(this);
  }
}

export class Liquidate__Params {
  _event: Liquidate;

  constructor(event: Liquidate) {
    this._event = event;
  }

  get asset(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get user(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get shareAmountRepaid(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get seizedCollateral(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Repay extends ethereum.Event {
  get params(): Repay__Params {
    return new Repay__Params(this);
  }
}

export class Repay__Params {
  _event: Repay;

  constructor(event: Repay) {
    this._event = event;
  }

  get asset(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get user(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Withdraw extends ethereum.Event {
  get params(): Withdraw__Params {
    return new Withdraw__Params(this);
  }
}

export class Withdraw__Params {
  _event: Withdraw;

  constructor(event: Withdraw) {
    this._event = event;
  }

  get asset(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get depositor(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get collateralOnly(): boolean {
    return this._event.parameters[4].value.toBoolean();
  }
}

export class Silo__assetStorageResultValue0Struct extends ethereum.Tuple {
  get collateralToken(): Address {
    return this[0].toAddress();
  }

  get collateralOnlyToken(): Address {
    return this[1].toAddress();
  }

  get debtToken(): Address {
    return this[2].toAddress();
  }

  get totalDeposits(): BigInt {
    return this[3].toBigInt();
  }

  get collateralOnlyDeposits(): BigInt {
    return this[4].toBigInt();
  }

  get totalBorrowAmount(): BigInt {
    return this[5].toBigInt();
  }
}

export class Silo__borrowResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getDebtAmount(): BigInt {
    return this.value0;
  }

  getDebtShare(): BigInt {
    return this.value1;
  }
}

export class Silo__borrowForResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getDebtAmount(): BigInt {
    return this.value0;
  }

  getDebtShare(): BigInt {
    return this.value1;
  }
}

export class Silo__depositResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getCollateralAmount(): BigInt {
    return this.value0;
  }

  getCollateralShare(): BigInt {
    return this.value1;
  }
}

export class Silo__depositForResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getCollateralAmount(): BigInt {
    return this.value0;
  }

  getCollateralShare(): BigInt {
    return this.value1;
  }
}

export class Silo__flashLiquidateResult {
  value0: Array<Address>;
  value1: Array<Array<BigInt>>;
  value2: Array<Array<BigInt>>;

  constructor(
    value0: Array<Address>,
    value1: Array<Array<BigInt>>,
    value2: Array<Array<BigInt>>
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddressArray(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigIntMatrix(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigIntMatrix(this.value2));
    return map;
  }

  getAssets(): Array<Address> {
    return this.value0;
  }

  getReceivedCollaterals(): Array<Array<BigInt>> {
    return this.value1;
  }

  getShareAmountsToRepay(): Array<Array<BigInt>> {
    return this.value2;
  }
}

export class Silo__getAssetsWithStateResultAssetsStorageStruct extends ethereum.Tuple {
  get collateralToken(): Address {
    return this[0].toAddress();
  }

  get collateralOnlyToken(): Address {
    return this[1].toAddress();
  }

  get debtToken(): Address {
    return this[2].toAddress();
  }

  get totalDeposits(): BigInt {
    return this[3].toBigInt();
  }

  get collateralOnlyDeposits(): BigInt {
    return this[4].toBigInt();
  }

  get totalBorrowAmount(): BigInt {
    return this[5].toBigInt();
  }
}

export class Silo__getAssetsWithStateResult {
  value0: Array<Address>;
  value1: Array<Silo__getAssetsWithStateResultAssetsStorageStruct>;

  constructor(
    value0: Array<Address>,
    value1: Array<Silo__getAssetsWithStateResultAssetsStorageStruct>
  ) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddressArray(this.value0));
    map.set("value1", ethereum.Value.fromTupleArray(this.value1));
    return map;
  }

  getAssets(): Array<Address> {
    return this.value0;
  }

  getAssetsStorage(): Array<Silo__getAssetsWithStateResultAssetsStorageStruct> {
    return this.value1;
  }
}

export class Silo__interestDataResultValue0Struct extends ethereum.Tuple {
  get harvestedProtocolFees(): BigInt {
    return this[0].toBigInt();
  }

  get protocolFees(): BigInt {
    return this[1].toBigInt();
  }

  get interestRateTimestamp(): BigInt {
    return this[2].toBigInt();
  }

  get status(): i32 {
    return this[3].toI32();
  }
}

export class Silo__repayResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getRepaidAmount(): BigInt {
    return this.value0;
  }

  getRepaidShare(): BigInt {
    return this.value1;
  }
}

export class Silo__repayForResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getRepaidAmount(): BigInt {
    return this.value0;
  }

  getRepaidShare(): BigInt {
    return this.value1;
  }
}

export class Silo__utilizationDataResultDataStruct extends ethereum.Tuple {
  get totalDeposits(): BigInt {
    return this[0].toBigInt();
  }

  get totalBorrowAmount(): BigInt {
    return this[1].toBigInt();
  }

  get interestRateTimestamp(): BigInt {
    return this[2].toBigInt();
  }
}

export class Silo__withdrawResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getWithdrawnAmount(): BigInt {
    return this.value0;
  }

  getWithdrawnShare(): BigInt {
    return this.value1;
  }
}

export class Silo__withdrawForResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getWithdrawnAmount(): BigInt {
    return this.value0;
  }

  getWithdrawnShare(): BigInt {
    return this.value1;
  }
}

export class Silo extends ethereum.SmartContract {
  static bind(address: Address): Silo {
    return new Silo("Silo", address);
  }

  VERSION(): BigInt {
    const result = super.call("VERSION", "VERSION():(uint128)", []);

    return result[0].toBigInt();
  }

  try_VERSION(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("VERSION", "VERSION():(uint128)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  accrueInterest(_asset: Address): BigInt {
    const result = super.call(
      "accrueInterest",
      "accrueInterest(address):(uint256)",
      [ethereum.Value.fromAddress(_asset)]
    );

    return result[0].toBigInt();
  }

  try_accrueInterest(_asset: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "accrueInterest",
      "accrueInterest(address):(uint256)",
      [ethereum.Value.fromAddress(_asset)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  assetStorage(_asset: Address): Silo__assetStorageResultValue0Struct {
    const result = super.call(
      "assetStorage",
      "assetStorage(address):((address,address,address,uint256,uint256,uint256))",
      [ethereum.Value.fromAddress(_asset)]
    );

    return changetype<Silo__assetStorageResultValue0Struct>(
      result[0].toTuple()
    );
  }

  try_assetStorage(
    _asset: Address
  ): ethereum.CallResult<Silo__assetStorageResultValue0Struct> {
    const result = super.tryCall(
      "assetStorage",
      "assetStorage(address):((address,address,address,uint256,uint256,uint256))",
      [ethereum.Value.fromAddress(_asset)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Silo__assetStorageResultValue0Struct>(value[0].toTuple())
    );
  }

  borrow(_asset: Address, _amount: BigInt): Silo__borrowResult {
    const result = super.call(
      "borrow",
      "borrow(address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );

    return new Silo__borrowResult(result[0].toBigInt(), result[1].toBigInt());
  }

  try_borrow(
    _asset: Address,
    _amount: BigInt
  ): ethereum.CallResult<Silo__borrowResult> {
    const result = super.tryCall(
      "borrow",
      "borrow(address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Silo__borrowResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  borrowFor(
    _asset: Address,
    _borrower: Address,
    _receiver: Address,
    _amount: BigInt
  ): Silo__borrowForResult {
    const result = super.call(
      "borrowFor",
      "borrowFor(address,address,address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_borrower),
        ethereum.Value.fromAddress(_receiver),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );

    return new Silo__borrowForResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_borrowFor(
    _asset: Address,
    _borrower: Address,
    _receiver: Address,
    _amount: BigInt
  ): ethereum.CallResult<Silo__borrowForResult> {
    const result = super.tryCall(
      "borrowFor",
      "borrowFor(address,address,address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_borrower),
        ethereum.Value.fromAddress(_receiver),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Silo__borrowForResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  borrowPossible(_asset: Address, _borrower: Address): boolean {
    const result = super.call(
      "borrowPossible",
      "borrowPossible(address,address):(bool)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_borrower)
      ]
    );

    return result[0].toBoolean();
  }

  try_borrowPossible(
    _asset: Address,
    _borrower: Address
  ): ethereum.CallResult<boolean> {
    const result = super.tryCall(
      "borrowPossible",
      "borrowPossible(address,address):(bool)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_borrower)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  deposit(
    _asset: Address,
    _amount: BigInt,
    _collateralOnly: boolean
  ): Silo__depositResult {
    const result = super.call(
      "deposit",
      "deposit(address,uint256,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromBoolean(_collateralOnly)
      ]
    );

    return new Silo__depositResult(result[0].toBigInt(), result[1].toBigInt());
  }

  try_deposit(
    _asset: Address,
    _amount: BigInt,
    _collateralOnly: boolean
  ): ethereum.CallResult<Silo__depositResult> {
    const result = super.tryCall(
      "deposit",
      "deposit(address,uint256,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromBoolean(_collateralOnly)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Silo__depositResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  depositFor(
    _asset: Address,
    _depositor: Address,
    _amount: BigInt,
    _collateralOnly: boolean
  ): Silo__depositForResult {
    const result = super.call(
      "depositFor",
      "depositFor(address,address,uint256,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_depositor),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromBoolean(_collateralOnly)
      ]
    );

    return new Silo__depositForResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_depositFor(
    _asset: Address,
    _depositor: Address,
    _amount: BigInt,
    _collateralOnly: boolean
  ): ethereum.CallResult<Silo__depositForResult> {
    const result = super.tryCall(
      "depositFor",
      "depositFor(address,address,uint256,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_depositor),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromBoolean(_collateralOnly)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Silo__depositForResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  depositPossible(_asset: Address, _depositor: Address): boolean {
    const result = super.call(
      "depositPossible",
      "depositPossible(address,address):(bool)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_depositor)
      ]
    );

    return result[0].toBoolean();
  }

  try_depositPossible(
    _asset: Address,
    _depositor: Address
  ): ethereum.CallResult<boolean> {
    const result = super.tryCall(
      "depositPossible",
      "depositPossible(address,address):(bool)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_depositor)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  flashLiquidate(
    _users: Array<Address>,
    _flashReceiverData: Bytes
  ): Silo__flashLiquidateResult {
    const result = super.call(
      "flashLiquidate",
      "flashLiquidate(address[],bytes):(address[],uint256[][],uint256[][])",
      [
        ethereum.Value.fromAddressArray(_users),
        ethereum.Value.fromBytes(_flashReceiverData)
      ]
    );

    return new Silo__flashLiquidateResult(
      result[0].toAddressArray(),
      result[1].toBigIntMatrix(),
      result[2].toBigIntMatrix()
    );
  }

  try_flashLiquidate(
    _users: Array<Address>,
    _flashReceiverData: Bytes
  ): ethereum.CallResult<Silo__flashLiquidateResult> {
    const result = super.tryCall(
      "flashLiquidate",
      "flashLiquidate(address[],bytes):(address[],uint256[][],uint256[][])",
      [
        ethereum.Value.fromAddressArray(_users),
        ethereum.Value.fromBytes(_flashReceiverData)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Silo__flashLiquidateResult(
        value[0].toAddressArray(),
        value[1].toBigIntMatrix(),
        value[2].toBigIntMatrix()
      )
    );
  }

  getAssets(): Array<Address> {
    const result = super.call("getAssets", "getAssets():(address[])", []);

    return result[0].toAddressArray();
  }

  try_getAssets(): ethereum.CallResult<Array<Address>> {
    const result = super.tryCall("getAssets", "getAssets():(address[])", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  getAssetsWithState(): Silo__getAssetsWithStateResult {
    const result = super.call(
      "getAssetsWithState",
      "getAssetsWithState():(address[],(address,address,address,uint256,uint256,uint256)[])",
      []
    );

    return new Silo__getAssetsWithStateResult(
      result[0].toAddressArray(),
      result[1].toTupleArray<
        Silo__getAssetsWithStateResultAssetsStorageStruct
      >()
    );
  }

  try_getAssetsWithState(): ethereum.CallResult<
    Silo__getAssetsWithStateResult
  > {
    const result = super.tryCall(
      "getAssetsWithState",
      "getAssetsWithState():(address[],(address,address,address,uint256,uint256,uint256)[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Silo__getAssetsWithStateResult(
        value[0].toAddressArray(),
        value[1].toTupleArray<
          Silo__getAssetsWithStateResultAssetsStorageStruct
        >()
      )
    );
  }

  harvestProtocolFees(): Array<BigInt> {
    const result = super.call(
      "harvestProtocolFees",
      "harvestProtocolFees():(uint256[])",
      []
    );

    return result[0].toBigIntArray();
  }

  try_harvestProtocolFees(): ethereum.CallResult<Array<BigInt>> {
    const result = super.tryCall(
      "harvestProtocolFees",
      "harvestProtocolFees():(uint256[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  interestData(_asset: Address): Silo__interestDataResultValue0Struct {
    const result = super.call(
      "interestData",
      "interestData(address):((uint256,uint256,uint64,uint8))",
      [ethereum.Value.fromAddress(_asset)]
    );

    return changetype<Silo__interestDataResultValue0Struct>(
      result[0].toTuple()
    );
  }

  try_interestData(
    _asset: Address
  ): ethereum.CallResult<Silo__interestDataResultValue0Struct> {
    const result = super.tryCall(
      "interestData",
      "interestData(address):((uint256,uint256,uint64,uint8))",
      [ethereum.Value.fromAddress(_asset)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Silo__interestDataResultValue0Struct>(value[0].toTuple())
    );
  }

  isSolvent(_user: Address): boolean {
    const result = super.call("isSolvent", "isSolvent(address):(bool)", [
      ethereum.Value.fromAddress(_user)
    ]);

    return result[0].toBoolean();
  }

  try_isSolvent(_user: Address): ethereum.CallResult<boolean> {
    const result = super.tryCall("isSolvent", "isSolvent(address):(bool)", [
      ethereum.Value.fromAddress(_user)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  liquidity(_asset: Address): BigInt {
    const result = super.call("liquidity", "liquidity(address):(uint256)", [
      ethereum.Value.fromAddress(_asset)
    ]);

    return result[0].toBigInt();
  }

  try_liquidity(_asset: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall("liquidity", "liquidity(address):(uint256)", [
      ethereum.Value.fromAddress(_asset)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  repay(_asset: Address, _amount: BigInt): Silo__repayResult {
    const result = super.call(
      "repay",
      "repay(address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );

    return new Silo__repayResult(result[0].toBigInt(), result[1].toBigInt());
  }

  try_repay(
    _asset: Address,
    _amount: BigInt
  ): ethereum.CallResult<Silo__repayResult> {
    const result = super.tryCall(
      "repay",
      "repay(address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Silo__repayResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  repayFor(
    _asset: Address,
    _borrower: Address,
    _amount: BigInt
  ): Silo__repayForResult {
    const result = super.call(
      "repayFor",
      "repayFor(address,address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_borrower),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );

    return new Silo__repayForResult(result[0].toBigInt(), result[1].toBigInt());
  }

  try_repayFor(
    _asset: Address,
    _borrower: Address,
    _amount: BigInt
  ): ethereum.CallResult<Silo__repayForResult> {
    const result = super.tryCall(
      "repayFor",
      "repayFor(address,address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_borrower),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Silo__repayForResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  siloAsset(): Address {
    const result = super.call("siloAsset", "siloAsset():(address)", []);

    return result[0].toAddress();
  }

  try_siloAsset(): ethereum.CallResult<Address> {
    const result = super.tryCall("siloAsset", "siloAsset():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  siloRepository(): Address {
    const result = super.call("siloRepository", "siloRepository():(address)", []);

    return result[0].toAddress();
  }

  try_siloRepository(): ethereum.CallResult<Address> {
    const result = super.tryCall(
      "siloRepository",
      "siloRepository():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  utilizationData(_asset: Address): Silo__utilizationDataResultDataStruct {
    const result = super.call(
      "utilizationData",
      "utilizationData(address):((uint256,uint256,uint64))",
      [ethereum.Value.fromAddress(_asset)]
    );

    return changetype<Silo__utilizationDataResultDataStruct>(
      result[0].toTuple()
    );
  }

  try_utilizationData(
    _asset: Address
  ): ethereum.CallResult<Silo__utilizationDataResultDataStruct> {
    const result = super.tryCall(
      "utilizationData",
      "utilizationData(address):((uint256,uint256,uint64))",
      [ethereum.Value.fromAddress(_asset)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Silo__utilizationDataResultDataStruct>(value[0].toTuple())
    );
  }

  withdraw(
    _asset: Address,
    _amount: BigInt,
    _collateralOnly: boolean
  ): Silo__withdrawResult {
    const result = super.call(
      "withdraw",
      "withdraw(address,uint256,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromBoolean(_collateralOnly)
      ]
    );

    return new Silo__withdrawResult(result[0].toBigInt(), result[1].toBigInt());
  }

  try_withdraw(
    _asset: Address,
    _amount: BigInt,
    _collateralOnly: boolean
  ): ethereum.CallResult<Silo__withdrawResult> {
    const result = super.tryCall(
      "withdraw",
      "withdraw(address,uint256,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromBoolean(_collateralOnly)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Silo__withdrawResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  withdrawFor(
    _asset: Address,
    _depositor: Address,
    _receiver: Address,
    _amount: BigInt,
    _collateralOnly: boolean
  ): Silo__withdrawForResult {
    const result = super.call(
      "withdrawFor",
      "withdrawFor(address,address,address,uint256,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_depositor),
        ethereum.Value.fromAddress(_receiver),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromBoolean(_collateralOnly)
      ]
    );

    return new Silo__withdrawForResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_withdrawFor(
    _asset: Address,
    _depositor: Address,
    _receiver: Address,
    _amount: BigInt,
    _collateralOnly: boolean
  ): ethereum.CallResult<Silo__withdrawForResult> {
    const result = super.tryCall(
      "withdrawFor",
      "withdrawFor(address,address,address,uint256,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_depositor),
        ethereum.Value.fromAddress(_receiver),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromBoolean(_collateralOnly)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new Silo__withdrawForResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _repository(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _siloAsset(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _version(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AccrueInterestCall extends ethereum.Call {
  get inputs(): AccrueInterestCall__Inputs {
    return new AccrueInterestCall__Inputs(this);
  }

  get outputs(): AccrueInterestCall__Outputs {
    return new AccrueInterestCall__Outputs(this);
  }
}

export class AccrueInterestCall__Inputs {
  _call: AccrueInterestCall;

  constructor(call: AccrueInterestCall) {
    this._call = call;
  }

  get _asset(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class AccrueInterestCall__Outputs {
  _call: AccrueInterestCall;

  constructor(call: AccrueInterestCall) {
    this._call = call;
  }

  get interest(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class BorrowCall extends ethereum.Call {
  get inputs(): BorrowCall__Inputs {
    return new BorrowCall__Inputs(this);
  }

  get outputs(): BorrowCall__Outputs {
    return new BorrowCall__Outputs(this);
  }
}

export class BorrowCall__Inputs {
  _call: BorrowCall;

  constructor(call: BorrowCall) {
    this._call = call;
  }

  get _asset(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class BorrowCall__Outputs {
  _call: BorrowCall;

  constructor(call: BorrowCall) {
    this._call = call;
  }

  get debtAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get debtShare(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class BorrowForCall extends ethereum.Call {
  get inputs(): BorrowForCall__Inputs {
    return new BorrowForCall__Inputs(this);
  }

  get outputs(): BorrowForCall__Outputs {
    return new BorrowForCall__Outputs(this);
  }
}

export class BorrowForCall__Inputs {
  _call: BorrowForCall;

  constructor(call: BorrowForCall) {
    this._call = call;
  }

  get _asset(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _borrower(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _receiver(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class BorrowForCall__Outputs {
  _call: BorrowForCall;

  constructor(call: BorrowForCall) {
    this._call = call;
  }

  get debtAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get debtShare(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class DepositCall extends ethereum.Call {
  get inputs(): DepositCall__Inputs {
    return new DepositCall__Inputs(this);
  }

  get outputs(): DepositCall__Outputs {
    return new DepositCall__Outputs(this);
  }
}

export class DepositCall__Inputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get _asset(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _collateralOnly(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class DepositCall__Outputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get collateralAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get collateralShare(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class DepositForCall extends ethereum.Call {
  get inputs(): DepositForCall__Inputs {
    return new DepositForCall__Inputs(this);
  }

  get outputs(): DepositForCall__Outputs {
    return new DepositForCall__Outputs(this);
  }
}

export class DepositForCall__Inputs {
  _call: DepositForCall;

  constructor(call: DepositForCall) {
    this._call = call;
  }

  get _asset(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _depositor(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _collateralOnly(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }
}

export class DepositForCall__Outputs {
  _call: DepositForCall;

  constructor(call: DepositForCall) {
    this._call = call;
  }

  get collateralAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get collateralShare(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FlashLiquidateCall extends ethereum.Call {
  get inputs(): FlashLiquidateCall__Inputs {
    return new FlashLiquidateCall__Inputs(this);
  }

  get outputs(): FlashLiquidateCall__Outputs {
    return new FlashLiquidateCall__Outputs(this);
  }
}

export class FlashLiquidateCall__Inputs {
  _call: FlashLiquidateCall;

  constructor(call: FlashLiquidateCall) {
    this._call = call;
  }

  get _users(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get _flashReceiverData(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class FlashLiquidateCall__Outputs {
  _call: FlashLiquidateCall;

  constructor(call: FlashLiquidateCall) {
    this._call = call;
  }

  get assets(): Array<Address> {
    return this._call.outputValues[0].value.toAddressArray();
  }

  get receivedCollaterals(): Array<Array<BigInt>> {
    return this._call.outputValues[1].value.toBigIntMatrix();
  }

  get shareAmountsToRepay(): Array<Array<BigInt>> {
    return this._call.outputValues[2].value.toBigIntMatrix();
  }
}

export class HarvestProtocolFeesCall extends ethereum.Call {
  get inputs(): HarvestProtocolFeesCall__Inputs {
    return new HarvestProtocolFeesCall__Inputs(this);
  }

  get outputs(): HarvestProtocolFeesCall__Outputs {
    return new HarvestProtocolFeesCall__Outputs(this);
  }
}

export class HarvestProtocolFeesCall__Inputs {
  _call: HarvestProtocolFeesCall;

  constructor(call: HarvestProtocolFeesCall) {
    this._call = call;
  }
}

export class HarvestProtocolFeesCall__Outputs {
  _call: HarvestProtocolFeesCall;

  constructor(call: HarvestProtocolFeesCall) {
    this._call = call;
  }

  get harvestedAmounts(): Array<BigInt> {
    return this._call.outputValues[0].value.toBigIntArray();
  }
}

export class InitAssetsTokensCall extends ethereum.Call {
  get inputs(): InitAssetsTokensCall__Inputs {
    return new InitAssetsTokensCall__Inputs(this);
  }

  get outputs(): InitAssetsTokensCall__Outputs {
    return new InitAssetsTokensCall__Outputs(this);
  }
}

export class InitAssetsTokensCall__Inputs {
  _call: InitAssetsTokensCall;

  constructor(call: InitAssetsTokensCall) {
    this._call = call;
  }
}

export class InitAssetsTokensCall__Outputs {
  _call: InitAssetsTokensCall;

  constructor(call: InitAssetsTokensCall) {
    this._call = call;
  }
}

export class RepayCall extends ethereum.Call {
  get inputs(): RepayCall__Inputs {
    return new RepayCall__Inputs(this);
  }

  get outputs(): RepayCall__Outputs {
    return new RepayCall__Outputs(this);
  }
}

export class RepayCall__Inputs {
  _call: RepayCall;

  constructor(call: RepayCall) {
    this._call = call;
  }

  get _asset(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RepayCall__Outputs {
  _call: RepayCall;

  constructor(call: RepayCall) {
    this._call = call;
  }

  get repaidAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get repaidShare(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class RepayForCall extends ethereum.Call {
  get inputs(): RepayForCall__Inputs {
    return new RepayForCall__Inputs(this);
  }

  get outputs(): RepayForCall__Outputs {
    return new RepayForCall__Outputs(this);
  }
}

export class RepayForCall__Inputs {
  _call: RepayForCall;

  constructor(call: RepayForCall) {
    this._call = call;
  }

  get _asset(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _borrower(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class RepayForCall__Outputs {
  _call: RepayForCall;

  constructor(call: RepayForCall) {
    this._call = call;
  }

  get repaidAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get repaidShare(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class SyncBridgeAssetsCall extends ethereum.Call {
  get inputs(): SyncBridgeAssetsCall__Inputs {
    return new SyncBridgeAssetsCall__Inputs(this);
  }

  get outputs(): SyncBridgeAssetsCall__Outputs {
    return new SyncBridgeAssetsCall__Outputs(this);
  }
}

export class SyncBridgeAssetsCall__Inputs {
  _call: SyncBridgeAssetsCall;

  constructor(call: SyncBridgeAssetsCall) {
    this._call = call;
  }
}

export class SyncBridgeAssetsCall__Outputs {
  _call: SyncBridgeAssetsCall;

  constructor(call: SyncBridgeAssetsCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get _asset(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _collateralOnly(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get withdrawnAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get withdrawnShare(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class WithdrawForCall extends ethereum.Call {
  get inputs(): WithdrawForCall__Inputs {
    return new WithdrawForCall__Inputs(this);
  }

  get outputs(): WithdrawForCall__Outputs {
    return new WithdrawForCall__Outputs(this);
  }
}

export class WithdrawForCall__Inputs {
  _call: WithdrawForCall;

  constructor(call: WithdrawForCall) {
    this._call = call;
  }

  get _asset(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _depositor(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _receiver(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _collateralOnly(): boolean {
    return this._call.inputValues[4].value.toBoolean();
  }
}

export class WithdrawForCall__Outputs {
  _call: WithdrawForCall;

  constructor(call: WithdrawForCall) {
    this._call = call;
  }

  get withdrawnAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get withdrawnShare(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}
